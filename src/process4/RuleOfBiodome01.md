# 객체 지향 프로그래밍 원칙 SOLID 다섯가지
## 신지우

### 목차
- SOLID 원칙의 등장과 필요성
- 다섯가지 원칙 소개
- 도서관 시스템에서 SOLID 원칙에 어긋나는 부분
### SOLID 원칙의 등장과 필요성
solid는 객체 지향 프로그래밍을 잘 하기 위해서 지켜야 하는 원칙입니다.

객체 지향 프로그래밍은 프로그램의 유지 보수를 간단히 잘 하기 위해서 필요합니다.

프로그램에 오류가 났을 때 수정하기 용이해야하니 간단한 코드를 보여주는 객체 지향 프로그래밍을 해야합니다.

객체 지향 프로그래밍의 핵심은 객체라는 개념을 중심으로 프로그램을 설계하는 것입니다. 객체는 데이터와 그 데이터를 처리하는 메서드를 포함하는 단위입니다.

이러한 객체 지향 프로그래밍의 원칙 중 하나가 SOLID 원칙입니다. SOLID 원칙은 소프트웨어 설계의 5가지 기본 원칙을 의미합니다.


### 다섯가지 원칙 소개

#### SRP (단일 책임 원칙)


단일 책임 원칙은 클래스가 하나의 책임만 가져야 한다는 원칙입니다. 이는 클래스가 변경되는 이유가 하나뿐이어야 한다는 것을 의미합니다.

예를 들어, 고양이 객체가 있다고 가정해 봅시다. 이 객체는 이름과 나이를 가지고 있으며, 먹고 걷는 기능을 수행할 수 있습니다.

하지만 고양이가 자신의 상태를 출력하는 기능을 가지는 것은 단일 책임 원칙을 위배하는 것입니다. 왜냐하면 출력은 고양이의 본래 책임이 아니기 때문입니다.

따라서 출력 기능은 별도의 프린터 객체나 출력하는 곳에서 처리해야 합니다. 이렇게 하면 클래스의 책임을 명확히 분리할 수 있습니다.

단일 책임 원칙을 준수하면 코드의 유지보수성이 향상되고, 변경에 유연하게 대응할 수 있습니다.


#### OCP (개방-폐쇄 원칙)

개방-폐쇄 원칙은 소프트웨어 엔티티는 확장에는 열려 있어야 하지만, 변경에는 닫혀 있어야 한다는 원칙입니다.

이는 새로운 기능을 추가할 때 기존 코드를 수정하지 않고도 확장할 수 있어야 한다는 것을 의미합니다.

예를 들어, 동물 객체가 있다고 가정해 봅시다. 이 객체는 다양한 동물 타입을 가질 수 있습니다. 새로운 동물 타입을 추가할 때 기존 코드를 수정하지 않고도 확장할 수 있어야 합니다.

왜냐하면 기존 코드를 수정하면 다른 부분에 영향을 미칠 수 있기 때문입니다. 따라서 상속을 통해 새로운 동물 타입을 추가하고, 필요한 메서드를 재정의하여 확장할 수 있습니다.

개방-폐쇄 원칙을 준수하면 코드의 확장성이 향상되고, 변경에 따른 리스크를 줄일 수 있습니다.

#### LSP (리스코프 치환 원칙)

리스코프 치환 원칙은 서브타입은 언제나 기반 타입으로 교체할 수 있어야 한다는 원칙입니다. 이는 서브타입이 기반 타입의 행동을 변경하지 않고 확장해야 한다는 것을 의미합니다.

예를 들어, 동물 객체가 있고, 이를 상속받은 고양이 객체가 있다고 가정해 봅시다. 고양이 객체는 동물 객체로 대체할 수 있어야 합니다.

왜냐하면 고양이 객체가 동물 객체의 행동을 변경하지 않고 확장해야 하기 때문입니다. 이를 통해 코드의 일관성을 유지할 수 있습니다.

리스코프 치환 원칙을 준수하면 코드의 재사용성이 향상되고, 객체 간의 관계를 명확히 할 수 있습니다.

이 원칙을 위반하면 코드의 예측 가능성이 떨어지고, 유지보수에 어려움을 겪을 수 있습니다.

#### ISP (인터페이스 분리 원칙)

인터페이스 분리 원칙은 클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 한다는 원칙입니다.

이는 인터페이스를 작고 구체적으로 만들어야 한다는 것을 의미합니다. 클라이언트는 자신이 필요한 메서드만 포함된 인터페이스를 구현해야 합니다.

예를 들어, 동물 인터페이스가 있다고 가정해 봅시다. 이 인터페이스는 먹기, 걷기, 날기 등의 메서드를 포함할 수 있습니다.

하지만 모든 동물이 날 수 있는 것은 아니기 때문에, 날기 메서드는 별도의 인터페이스로 분리해야 합니다. 왜냐하면 클라이언트가 자신이 사용하지 않는 메서드에 의존하지 않도록 하기 때문입니다.

인터페이스 분리 원칙을 준수하면 코드의 유연성이 향상되고, 변경에 따른 영향을 최소화할 수 있습니다.

#### DIP (의존 관계 역전 원칙)

의존 관계 역전 원칙은 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 한다는 원칙입니다.

이는 구체적인 구현이 아닌, 추상화된 인터페이스에 의존해야 한다는 것을 의미합니다. 이를 통해 모듈 간의 결합도를 낮출 수 있습니다.

예를 들어, 데이터베이스에 접근하는 모듈이 있다고 가정해 봅시다. 이 모듈은 특정 데이터베이스 구현에 의존해서는 안 됩니다.

왜냐하면 특정 구현에 의존하면, 다른 데이터베이스로 변경할 때 많은 수정이 필요하기 때문입니다. 따라서 추상화된 인터페이스를 통해 데이터베이스에 접근해야 합니다.

의존 관계 역전 원칙을 준수하면 코드의 유연성이 향상되고, 변경에 따른 리스크를 줄일 수 있습니다.


### 도서관 시스템에서 SOLID 원칙에 어긋나는 부분

1.
```
abstract class User {
    public String userId;
    public String name;

    public User(String userId, String name) {
        this.userId = userId;
        this.name = name;
    }

    public void borrowBook(Book book) {
        if(!book.isBorrowed) {
            book.isBorrowed = true;
        }
    }

    public void returnBook(Book book) {
        if(book.isBorrowed) {
            book.isBorrowed = false;
        }
    }

	abstract void addBook(Book book, Library library);
	abstract void removeBook(Book book, Library library); 

}
```
위 코드는 SRP를 위반했습니다. 

하나의 클래스가 하나의 책임만을 가져야하는데 borrowBook, returnBook의 책임을 동시에 갖고 있습니다.

해결 방법 : 여러 책임들 별도로 분리합니다.


2.
```
    public void addMember(Member member) {
        users.add(member);
    }

    public void addManager(Manager manager) {
        users.add(manager);
    }
```
위 코드는 OCP를 위반했습니다.

만약 새로운 사용자 타입이 추가되면 이 코드를 수정해야 하기 때문입니다.

해결 방법 : member,manager 말고 user를 사용하여 user를 상속받아 구현합니다.


3.
```
public void addBook(Book book, Library library) {
				System.out.println("Member can't add book");
		}
		public void removeBook(Book book, Library library) {
				System.out.println("Member can't remove book");
		}
```
위 코드는 LSP를 위반했습니다.

Member는 user를 상속받지만, addBook과 removeBook의 본 의미를 깨뜨려서 Manager의 addBook, removeBook이 실행될 때와 완전 다른 의미를 갖기 때문입니다.

해결 방법 : User 클래스에는 addBook과 removeBook을 넣지 말고 Manager에만 해당 기능을 인터페이스 또는 별도 역할로 분리합니다.